# Copyright (c) 2026 Dmitry Feklin (FeklinDN@gmail.com)
# This script is provided for T-ISA VM data generation.

import urllib.request

# --- CONFIGURATION ---
UNICODE_VERSION = "13.0.0"
OUTPUT_FILENAME = "TISA_UCD_TABLES.h"
# Категории для генерации. 'P' и 'Z' - это главные категории,
# скрипт соберет все подкатегории (Po, Ps, Zs, Zl и т.д.)
CATEGORIES_TO_GENERATE = ['Mn', 'Cc', 'Cf', 'P', 'Z']

# --- URL ---
UNICODE_DATA_URL = f"https://www.unicode.org/Public/{UNICODE_VERSION}/ucd/UnicodeData.txt"

def download_file(url):
    print(f"Downloading {url}...")
    with urllib.request.urlopen(url) as response:
        return response.read().decode('utf-8')

def parse_unicode_data(data):
    decompositions = {}
    categories = {}
    lowercase_map = {}
    
    for line in data.splitlines():
        parts = line.strip().split(';')
        if len(parts) < 14:
            continue
            
        codepoint = int(parts[0], 16)
        category_code = parts[2]
        decomp_str = parts[5]
        lower_str = parts[13]

        if category_code not in categories:
            categories[category_code] = []
        categories[category_code].append(codepoint)
        
        if lower_str:
            lowercase_map[codepoint] = int(lower_str, 16)
        
        if decomp_str and not decomp_str.startswith('<'):
            decomp_parts = [int(p, 16) for p in decomp_str.split()]
            if len(decomp_parts) <= 2:
                decompositions[codepoint] = decomp_parts

    return decompositions, categories, lowercase_map

def build_ranges(codepoints):
    if not codepoints:
        return []
    codepoints = sorted(list(set(codepoints)))
    ranges = []
    start = codepoints[0]
    end = codepoints[0]
    for i in range(1, len(codepoints)):
        if codepoints[i] == end + 1:
            end = codepoints[i]
        else:
            ranges.append((start, end))
            start = codepoints[i]
            end = codepoints[i]
    ranges.append((start, end))
    return ranges

def build_lowercase_tables(mappings):
    ranges = []
    exceptions = {}
    
    sorted_cps = sorted(mappings.keys())
    
    i = 0
    while i < len(sorted_cps):
        start_cp = sorted_cps[i]
        
        if i + 1 < len(sorted_cps) and \
           sorted_cps[i+1] == start_cp + 1 and \
           mappings.get(sorted_cps[i+1]) == mappings.get(start_cp) + 1:
            
            current_cp = start_cp
            delta = mappings[current_cp] - current_cp
            end_cp = current_cp
            j = i + 1
            while j < len(sorted_cps) and \
                  sorted_cps[j] == current_cp + 1 and \
                  mappings.get(sorted_cps[j]) == sorted_cps[j] + delta:
                current_cp = sorted_cps[j]
                end_cp = current_cp
                j += 1
            
            ranges.append((start_cp, end_cp, delta))
            i = j
        else:
            exceptions[start_cp] = mappings[start_cp]
            i += 1
            
    return ranges, exceptions

def write_header_file(filename, lowercase_ranges, lowercase_exceptions, decomp_table, cat_tables):
    print(f"Writing to {filename}...")
    with open(filename, "w", encoding="utf-8") as f:
        f.write("// Generated by generate_ucd_tables.py\n")
        f.write("// DO NOT EDIT MANUALLY\n\n")
        f.write("#ifndef TISA_UCD_TABLES_H\n")
        f.write("#define TISA_UCD_TABLES_H\n\n")
        f.write("#include <Arduino.h>\n\n")

        f.write("namespace {\n")
        f.write("    struct UnicodeRange { uint32_t start, end; int32_t delta; };\n")
        f.write("    struct UnicodeException { uint32_t from, to; };\n")
        f.write("    struct Decomp { uint32_t from; uint32_t to1; uint32_t to2; };\n")
        f.write("    struct CategoryRange { uint32_t start, end; };\n\n")

        f.write("    static const UnicodeRange LOWERCASE_RANGES[] PROGMEM = {\n")
        for start, end, delta in sorted(lowercase_ranges):
            f.write(f"        {{0x{start:04X}, 0x{end:04X}, {delta}}},\n")
        f.write("    };\n\n")

        f.write("    static const UnicodeException LOWERCASE_EXCEPTIONS[] PROGMEM = {\n")
        for from_cp, to_cp in sorted(lowercase_exceptions.items()):
            f.write(f"        {{0x{from_cp:04X}, 0x{to_cp:04X}}},\n")
        f.write("    };\n\n")

        f.write("    static const Decomp DECOMP_TABLE[] PROGMEM = {\n")
        for from_cp, to_cps in sorted(decomp_table.items()):
            to1 = to_cps[0]
            to2 = to_cps[1] if len(to_cps) > 1 else 0
            f.write(f"        {{0x{from_cp:04X}, 0x{to1:04X}, 0x{to2:04X}}},\n")
        f.write("    };\n\n")
        
        # Сортируем категории для консистентного вывода
        for cat_name in sorted(cat_tables.keys()):
            ranges = cat_tables[cat_name]
            f.write(f"    static const CategoryRange CAT_{cat_name.upper()}_RANGES[] PROGMEM = {{\n")
            if not ranges:
                 f.write("        // This category is empty for the given Unicode version.\n")
            for start, end in ranges:
                 f.write(f"        {{0x{start:04X}, 0x{end:04X}}},\n")
            f.write("    };\n\n")

        f.write("} // anonymous namespace\n\n")
        f.write("#endif // TISA_UCD_TABLES_H\n")
    print("Done.")

if __name__ == "__main__":
    ucd_content = download_file(UNICODE_DATA_URL)
    decompositions, categories_data, lowercase_map = parse_unicode_data(ucd_content)
    
    lranges, lexceptions = build_lowercase_tables(lowercase_map)

    final_cat_tables = {cat: [] for cat in CATEGORIES_TO_GENERATE}
    aggregated_codepoints = {cat: [] for cat in CATEGORIES_TO_GENERATE}

    for specific_cat, codepoints in categories_data.items():
        # Для однобуквенных главных категорий (P, Z, L, M, N, S, C)
        major_cat = specific_cat[0]
        if major_cat in aggregated_codepoints:
            aggregated_codepoints[major_cat].extend(codepoints)
        # Для полных кодов категорий (Mn, Cc, Cf)
        if specific_cat in aggregated_codepoints:
            aggregated_codepoints[specific_cat].extend(codepoints)
    
    # Создаем диапазоны из агрегированных кодовых точек
    for cat_name, codepoints in aggregated_codepoints.items():
        if codepoints:
            final_cat_tables[cat_name] = build_ranges(codepoints)
            print(f"Generated {len(final_cat_tables[cat_name])} ranges for category '{cat_name}'.")

    write_header_file(OUTPUT_FILENAME, lranges, lexceptions, decompositions, final_cat_tables)